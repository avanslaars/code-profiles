/**
 * @license Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try {
            step(generator.next(value));
        }
        catch (e) {
            reject(e);
        } }
        function rejected(value) { try {
            step(generator["throw"](value));
        }
        catch (e) {
            reject(e);
        } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var childProcess = require("child_process");
var fs = require("fs");
var net = require("net");
var rimraf = require("rimraf");
var chromeFinder = require("./chrome-finder");
var random_port_1 = require("./random-port");
var flags_1 = require("./flags");
var utils_1 = require("./utils");
var log = require('lighthouse-logger');
var spawn = childProcess.spawn;
var execSync = childProcess.execSync;
var isWsl = utils_1.getPlatform() === 'wsl';
var isWindows = utils_1.getPlatform() === 'win32';
var _SIGINT = 'SIGINT';
var _SIGINT_EXIT_CODE = 130;
var _SUPPORTED_PLATFORMS = new Set(['darwin', 'linux', 'win32', 'wsl']);
var instances = new Set();
var sigintListener = function () { return __awaiter(_this, void 0, void 0, function () {
    var _i, instances_1, instance;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _i = 0, instances_1 = instances;
                _a.label = 1;
            case 1:
                if (!(_i < instances_1.length)) return [3 /*break*/, 4];
                instance = instances_1[_i];
                return [4 /*yield*/, instance.kill()];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3:
                _i++;
                return [3 /*break*/, 1];
            case 4:
                process.exit(_SIGINT_EXIT_CODE);
                return [2 /*return*/];
        }
    });
}); };
function launch(opts) {
    if (opts === void 0) { opts = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        var instance, kill;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    opts.handleSIGINT = utils_1.defaults(opts.handleSIGINT, true);
                    instance = new Launcher(opts);
                    // Kill spawned Chrome process in case of ctrl-C.
                    if (opts.handleSIGINT && instances.size === 0) {
                        process.on(_SIGINT, sigintListener);
                    }
                    instances.add(instance);
                    return [4 /*yield*/, instance.launch()];
                case 1:
                    _a.sent();
                    kill = function () { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            instances.delete(instance);
                            if (instances.size === 0) {
                                process.removeListener(_SIGINT, sigintListener);
                            }
                            return [2 /*return*/, instance.kill()];
                        });
                    }); };
                    return [2 /*return*/, { pid: instance.pid, port: instance.port, kill: kill }];
            }
        });
    });
}
exports.launch = launch;
var Launcher = /** @class */ (function () {
    function Launcher(opts, moduleOverrides) {
        if (opts === void 0) { opts = {}; }
        if (moduleOverrides === void 0) { moduleOverrides = {}; }
        this.opts = opts;
        this.tmpDirandPidFileReady = false;
        this.fs = moduleOverrides.fs || fs;
        this.rimraf = moduleOverrides.rimraf || rimraf;
        this.spawn = moduleOverrides.spawn || spawn;
        log.setLevel(utils_1.defaults(this.opts.logLevel, 'silent'));
        // choose the first one (default)
        this.startingUrl = utils_1.defaults(this.opts.startingUrl, 'about:blank');
        this.chromeFlags = utils_1.defaults(this.opts.chromeFlags, []);
        this.requestedPort = utils_1.defaults(this.opts.port, 0);
        this.chromePath = this.opts.chromePath;
        this.enableExtensions = utils_1.defaults(this.opts.enableExtensions, false);
        this.connectionPollInterval = utils_1.defaults(this.opts.connectionPollInterval, 500);
        this.maxConnectionRetries = utils_1.defaults(this.opts.maxConnectionRetries, 50);
    }
    Object.defineProperty(Launcher.prototype, "flags", {
        get: function () {
            var flags = flags_1.DEFAULT_FLAGS.concat([
                "--remote-debugging-port=" + this.port,
                // Place Chrome profile in a custom location we'll rm -rf later
                // If in WSL, we need to use the Windows format
                "--user-data-dir=" + (isWsl ? utils_1.toWinDirFormat(this.userDataDir) : this.userDataDir)
            ]);
            if (this.enableExtensions) {
                flags = flags.filter(function (flag) { return flag !== '--disable-extensions'; });
            }
            if (utils_1.getPlatform() === 'linux') {
                flags.push('--disable-setuid-sandbox');
            }
            flags.push.apply(flags, this.chromeFlags);
            flags.push(this.startingUrl);
            return flags;
        },
        enumerable: true,
        configurable: true
    });
    // Wrapper function to enable easy testing.
    Launcher.prototype.makeTmpDir = function () {
        return utils_1.makeTmpDir();
    };
    Launcher.prototype.prepare = function () {
        var platform = utils_1.getPlatform();
        if (!_SUPPORTED_PLATFORMS.has(platform)) {
            throw new Error("Platform " + platform + " is not supported");
        }
        this.userDataDir = this.opts.userDataDir || this.makeTmpDir();
        this.outFile = this.fs.openSync(this.userDataDir + "/chrome-out.log", 'a');
        this.errFile = this.fs.openSync(this.userDataDir + "/chrome-err.log", 'a');
        // fix for Node4
        // you can't pass a fd to fs.writeFileSync
        this.pidFile = this.userDataDir + "/chrome.pid";
        log.verbose('ChromeLauncher', "created " + this.userDataDir);
        this.tmpDirandPidFileReady = true;
    };
    Launcher.prototype.launch = function () {
        return __awaiter(this, void 0, void 0, function () {
            var err_1, installations, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.requestedPort !== 0)) return [3 /*break*/, 4];
                        this.port = this.requestedPort;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.isDebuggerReady()];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        err_1 = _b.sent();
                        log.log('ChromeLauncher', "No debugging port found on port " + this.port + ", launching a new Chrome.");
                        return [3 /*break*/, 4];
                    case 4:
                        if (!(this.chromePath === undefined)) return [3 /*break*/, 6];
                        return [4 /*yield*/, chromeFinder[utils_1.getPlatform()]()];
                    case 5:
                        installations = _b.sent();
                        if (installations.length === 0) {
                            throw new Error('No Chrome Installations Found');
                        }
                        this.chromePath = installations[0];
                        _b.label = 6;
                    case 6:
                        if (!this.tmpDirandPidFileReady) {
                            this.prepare();
                        }
                        _a = this;
                        return [4 /*yield*/, this.spawnProcess(this.chromePath)];
                    case 7:
                        _a.pid = _b.sent();
                        return [2 /*return*/, Promise.resolve()];
                }
            });
        });
    };
    Launcher.prototype.spawnProcess = function (execPath) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var spawnPromise, pid;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spawnPromise = (function () { return __awaiter(_this, void 0, void 0, function () {
                            var _a, chrome;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        if (this.chrome) {
                                            log.log('ChromeLauncher', "Chrome already running with pid " + this.chrome.pid + ".");
                                            return [2 /*return*/, this.chrome.pid];
                                        }
                                        if (!(this.requestedPort === 0)) return [3 /*break*/, 2];
                                        _a = this;
                                        return [4 /*yield*/, random_port_1.getRandomPort()];
                                    case 1:
                                        _a.port = _b.sent();
                                        _b.label = 2;
                                    case 2:
                                        log.verbose('ChromeLauncher', "Launching with command:\n\"" + execPath + "\" " + this.flags.join(' '));
                                        chrome = this.spawn(execPath, this.flags, { detached: true, stdio: ['ignore', this.outFile, this.errFile] });
                                        this.chrome = chrome;
                                        this.fs.writeFileSync(this.pidFile, chrome.pid.toString());
                                        log.verbose('ChromeLauncher', "Chrome running with pid " + chrome.pid + " on port " + this.port + ".");
                                        return [2 /*return*/, chrome.pid];
                                }
                            });
                        }); })();
                        return [4 /*yield*/, spawnPromise];
                    case 1:
                        pid = _a.sent();
                        return [4 /*yield*/, this.waitUntilReady()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, pid];
                }
            });
        });
    };
    Launcher.prototype.cleanup = function (client) {
        if (client) {
            client.removeAllListeners();
            client.end();
            client.destroy();
            client.unref();
        }
    };
    // resolves if ready, rejects otherwise
    Launcher.prototype.isDebuggerReady = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var client = net.createConnection(_this.port);
            client.once('error', function (err) {
                _this.cleanup(client);
                reject(err);
            });
            client.once('connect', function () {
                _this.cleanup(client);
                resolve();
            });
        });
    };
    // resolves when debugger is ready, rejects after 10 polls
    Launcher.prototype.waitUntilReady = function () {
        var _this = this;
        var launcher = this;
        return new Promise(function (resolve, reject) {
            var retries = 0;
            var waitStatus = 'Waiting for browser.';
            var poll = function () {
                if (retries === 0) {
                    log.log('ChromeLauncher', waitStatus);
                }
                retries++;
                waitStatus += '..';
                log.log('ChromeLauncher', waitStatus);
                launcher.isDebuggerReady()
                    .then(function () {
                    log.log('ChromeLauncher', waitStatus + ("" + log.greenify(log.tick)));
                    resolve();
                })
                    .catch(function (err) {
                    if (retries > launcher.maxConnectionRetries) {
                        log.error('ChromeLauncher', err.message);
                        var stderr = _this.fs.readFileSync(_this.userDataDir + "/chrome-err.log", { encoding: 'utf-8' });
                        log.error('ChromeLauncher', "Logging contents of " + _this.userDataDir + "/chrome-err.log");
                        log.error('ChromeLauncher', stderr);
                        return reject(err);
                    }
                    utils_1.delay(launcher.connectionPollInterval).then(poll);
                });
            };
            poll();
        });
    };
    Launcher.prototype.kill = function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.chrome) {
                _this.chrome.on('close', function () {
                    _this.destroyTmp().then(resolve);
                });
                log.log('ChromeLauncher', "Killing Chrome instance " + _this.chrome.pid);
                try {
                    if (isWindows) {
                        execSync("taskkill /pid " + _this.chrome.pid + " /T /F");
                    }
                    else {
                        process.kill(-_this.chrome.pid);
                    }
                }
                catch (err) {
                    log.warn('ChromeLauncher', "Chrome could not be killed " + err.message);
                }
                delete _this.chrome;
            }
            else {
                // fail silently as we did not start chrome
                resolve();
            }
        });
    };
    Launcher.prototype.destroyTmp = function () {
        var _this = this;
        return new Promise(function (resolve) {
            // Only clean up the tmp dir if we created it.
            if (_this.userDataDir === undefined || _this.opts.userDataDir !== undefined) {
                return resolve();
            }
            if (_this.outFile) {
                _this.fs.closeSync(_this.outFile);
                delete _this.outFile;
            }
            if (_this.errFile) {
                _this.fs.closeSync(_this.errFile);
                delete _this.errFile;
            }
            _this.rimraf(_this.userDataDir, function () { return resolve(); });
        });
    };
    return Launcher;
}());
exports.Launcher = Launcher;
;
