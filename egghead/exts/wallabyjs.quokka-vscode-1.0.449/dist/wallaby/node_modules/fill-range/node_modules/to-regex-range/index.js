/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var isNumber = require('is-number');
var toRegexRange = function (min, max, options) {
    if (isNumber(min) === false) {
        throw new TypeError('toRegexRange: expected the first argument to be a number');
    }
    if (max === void 0 || min === max) {
        return String(min);
    }
    if (isNumber(max) === false) {
        throw new TypeError('toRegexRange: expected the second argument to be a number.');
    }
    var opts = __assign({ relaxZeros: true }, options);
    if (typeof opts.strictZeros === 'boolean') {
        opts.relaxZeros = opts.strictZeros === false;
    }
    var relax = String(opts.relaxZeros);
    var shorthand = String(opts.shorthand);
    var capture = String(opts.capture);
    var wrap = String(opts.wrap);
    var cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
    }
    var a = Math.min(min, max);
    var b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
        var result = min + '|' + max;
        if (opts.capture) {
            return "(" + result + ")";
        }
        if (opts.wrap === false) {
            return result;
        }
        return "(?:" + result + ")";
    }
    var isPadded = hasPadding(min) || hasPadding(max);
    var state = { min: min, max: max, a: a, b: b };
    var positives = [];
    var negatives = [];
    if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
    }
    if (a < 0) {
        var newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
    }
    if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
        state.result = "(" + state.result + ")";
    }
    else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
        state.result = "(?:" + state.result + ")";
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
};
function collatePatterns(neg, pos, options) {
    var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
    var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
    var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
    var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
}
function splitToRanges(min, max) {
    var nines = 1;
    var zeros = 1;
    var stop = countNines(min, nines);
    var stops = new Set([max]);
    while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
    }
    stop = countZeros(max + 1, zeros) - 1;
    while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
    }
    stops = __spreadArray([], stops, true);
    stops.sort(compare);
    return stops;
}
/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */
function rangeToPattern(start, stop, options) {
    if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
    }
    var zipped = zip(start, stop);
    var digits = zipped.length;
    var pattern = '';
    var count = 0;
    for (var i = 0; i < digits; i++) {
        var _a = zipped[i], startDigit = _a[0], stopDigit = _a[1];
        if (startDigit === stopDigit) {
            pattern += startDigit;
        }
        else if (startDigit !== '0' || stopDigit !== '9') {
            pattern += toCharacterClass(startDigit, stopDigit, options);
        }
        else {
            count++;
        }
    }
    if (count) {
        pattern += options.shorthand === true ? '\\d' : '[0-9]';
    }
    return { pattern: pattern, count: [count], digits: digits };
}
function splitToPatterns(min, max, tok, options) {
    var ranges = splitToRanges(min, max);
    var tokens = [];
    var start = min;
    var prev;
    for (var i = 0; i < ranges.length; i++) {
        var max_1 = ranges[i];
        var obj = rangeToPattern(String(start), String(max_1), options);
        var zeros = '';
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
                prev.count.pop();
            }
            prev.count.push(obj.count[0]);
            prev.string = prev.pattern + toQuantifier(prev.count);
            start = max_1 + 1;
            continue;
        }
        if (tok.isPadded) {
            zeros = padZeros(max_1, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max_1 + 1;
        prev = obj;
    }
    return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options) {
    var result = [];
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var ele = arr_1[_i];
        var string = ele.string;
        // only push if _both_ are negative...
        if (!intersection && !contains(comparison, 'string', string)) {
            result.push(prefix + string);
        }
        // or _both_ are positive
        if (intersection && contains(comparison, 'string', string)) {
            result.push(prefix + string);
        }
    }
    return result;
}
/**
 * Zip strings
 */
function zip(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
    return arr;
}
function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key, val) {
    return arr.some(function (ele) { return ele[key] === val; });
}
function countNines(min, len) {
    return Number(String(min).slice(0, -len) + '9'.repeat(len));
}
function countZeros(integer, zeros) {
    return integer - (integer % Math.pow(10, zeros));
}
function toQuantifier(digits) {
    var _a = digits[0], start = _a === void 0 ? 0 : _a, _b = digits[1], stop = _b === void 0 ? '' : _b;
    if (stop || start > 1) {
        return "{" + (start + (stop ? ',' + stop : '')) + "}";
    }
    return '';
}
function toCharacterClass(a, b, options) {
    return "[" + a + ((b - a === 1) ? '' : '-') + b + "]";
}
function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
}
function padZeros(value, tok, options) {
    if (!tok.isPadded) {
        return value;
    }
    var diff = Math.abs(tok.maxLen - String(value).length);
    var relax = options.relaxZeros !== false;
    switch (diff) {
        case 0:
            return '';
        case 1:
            return relax ? '0?' : '0';
        case 2:
            return relax ? '0{0,2}' : '00';
        default: {
            return relax ? "0{0," + diff + "}" : "0{" + diff + "}";
        }
    }
}
/**
 * Cache
 */
toRegexRange.cache = {};
toRegexRange.clearCache = function () { return (toRegexRange.cache = {}); };
/**
 * Expose `toRegexRange`
 */
module.exports = toRegexRange;
