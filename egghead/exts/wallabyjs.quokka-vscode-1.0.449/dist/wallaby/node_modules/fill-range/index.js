/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var util = require('util');
var toRegexRange = require('to-regex-range');
var isObject = function (val) { return val !== null && typeof val === 'object' && !Array.isArray(val); };
var transform = function (toNumber) {
    return function (value) { return toNumber === true ? Number(value) : String(value); };
};
var isValidValue = function (value) {
    return typeof value === 'number' || (typeof value === 'string' && value !== '');
};
var isNumber = function (num) { return Number.isInteger(+num); };
var zeros = function (input) {
    var value = "" + input;
    var index = -1;
    if (value[0] === '-')
        value = value.slice(1);
    if (value === '0')
        return false;
    while (value[++index] === '0')
        ;
    return index > 0;
};
var stringify = function (start, end, options) {
    if (typeof start === 'string' || typeof end === 'string') {
        return true;
    }
    return options.stringify === true;
};
var pad = function (input, maxLength, toNumber) {
    if (maxLength > 0) {
        var dash = input[0] === '-' ? '-' : '';
        if (dash)
            input = input.slice(1);
        input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
    }
    if (toNumber === false) {
        return String(input);
    }
    return input;
};
var toMaxLen = function (input, maxLength) {
    var negative = input[0] === '-' ? '-' : '';
    if (negative) {
        input = input.slice(1);
        maxLength--;
    }
    while (input.length < maxLength)
        input = '0' + input;
    return negative ? ('-' + input) : input;
};
var toSequence = function (parts, options) {
    parts.negatives.sort(function (a, b) { return a < b ? -1 : a > b ? 1 : 0; });
    parts.positives.sort(function (a, b) { return a < b ? -1 : a > b ? 1 : 0; });
    var prefix = options.capture ? '' : '?:';
    var positives = '';
    var negatives = '';
    var result;
    if (parts.positives.length) {
        positives = parts.positives.join('|');
    }
    if (parts.negatives.length) {
        negatives = "-(" + prefix + parts.negatives.join('|') + ")";
    }
    if (positives && negatives) {
        result = positives + "|" + negatives;
    }
    else {
        result = positives || negatives;
    }
    if (options.wrap) {
        return "(" + prefix + result + ")";
    }
    return result;
};
var toRange = function (a, b, isNumbers, options) {
    if (isNumbers) {
        return toRegexRange(a, b, __assign({ wrap: false }, options));
    }
    var start = String.fromCharCode(a);
    if (a === b)
        return start;
    var stop = String.fromCharCode(b);
    return "[" + start + "-" + stop + "]";
};
var toRegex = function (start, end, options) {
    if (Array.isArray(start)) {
        var wrap = options.wrap === true;
        var prefix = options.capture ? '' : '?:';
        return wrap ? "(" + prefix + start.join('|') + ")" : start.join('|');
    }
    return toRegexRange(start, end, options);
};
var rangeError = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return new RangeError('Invalid range arguments: ' + util.inspect.apply(util, args));
};
var invalidRange = function (start, end, options) {
    if (options.strictRanges === true)
        throw rangeError([start, end]);
    return [];
};
var invalidStep = function (step, options) {
    if (options.strictRanges === true) {
        throw new TypeError("Expected step \"" + step + "\" to be a number");
    }
    return [];
};
var fillNumbers = function (start, end, step, options) {
    if (step === void 0) { step = 1; }
    if (options === void 0) { options = {}; }
    var a = Number(start);
    var b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
            throw rangeError([start, end]);
        return [];
    }
    // fix negative zero
    if (a === 0)
        a = 0;
    if (b === 0)
        b = 0;
    var descending = a > b;
    var startString = String(start);
    var endString = String(end);
    var stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    var padded = zeros(startString) || zeros(endString) || zeros(stepString);
    var maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    var toNumber = padded === false && stringify(start, end, options) === false;
    var format = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    var parts = { negatives: [], positives: [] };
    var push = function (num) { return parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num)); };
    var range = [];
    var index = 0;
    while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
            push(a);
        }
        else {
            range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
    }
    if (options.toRegex === true) {
        return step > 1
            ? toSequence(parts, options)
            : toRegex(range, null, __assign({ wrap: false }, options));
    }
    return range;
};
var fillLetters = function (start, end, step, options) {
    if (step === void 0) { step = 1; }
    if (options === void 0) { options = {}; }
    if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
        return invalidRange(start, end, options);
    }
    var format = options.transform || (function (val) { return String.fromCharCode(val); });
    var a = ("" + start).charCodeAt(0);
    var b = ("" + end).charCodeAt(0);
    var descending = a > b;
    var min = Math.min(a, b);
    var max = Math.max(a, b);
    if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
    }
    var range = [];
    var index = 0;
    while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
    }
    if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options: options });
    }
    return range;
};
var fill = function (start, end, step, options) {
    if (options === void 0) { options = {}; }
    if (end == null && isValidValue(start)) {
        return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
    }
    if (typeof step === 'function') {
        return fill(start, end, 1, { transform: step });
    }
    if (isObject(step)) {
        return fill(start, end, 0, step);
    }
    var opts = __assign({}, options);
    if (opts.capture === true)
        opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
        if (step != null && !isObject(step))
            return invalidStep(step, opts);
        return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};
module.exports = fill;
