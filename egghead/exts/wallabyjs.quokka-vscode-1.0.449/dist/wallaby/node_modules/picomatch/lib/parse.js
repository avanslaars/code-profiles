'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var constants = require('./constants');
var utils = require('./utils');
/**
 * Constants
 */
var MAX_LENGTH = constants.MAX_LENGTH, POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS = constants.REPLACEMENTS;
/**
 * Helpers
 */
var expandRange = function (args, options) {
    if (typeof options.expandRange === 'function') {
        return options.expandRange.apply(options, __spreadArray(__spreadArray([], args, false), [options], false));
    }
    args.sort();
    var value = "[" + args.join('-') + "]";
    try {
        /* eslint-disable-next-line no-new */
        new RegExp(value);
    }
    catch (ex) {
        return args.map(function (v) { return utils.escapeRegex(v); }).join('..');
    }
    return value;
};
/**
 * Create the message for a syntax error
 */
var syntaxError = function (type, char) {
    return "Missing " + type + ": \"" + char + "\" - use \"\\\\" + char + "\" to match literal characters";
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */
var parse = function (input, options) {
    if (typeof input !== 'string') {
        throw new TypeError('Expected a string');
    }
    input = REPLACEMENTS[input] || input;
    var opts = __assign({}, options);
    var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    var len = input.length;
    if (len > max) {
        throw new SyntaxError("Input length: " + len + ", exceeds maximum allowed length: " + max);
    }
    var bos = { type: 'bos', value: '', output: opts.prepend || '' };
    var tokens = [bos];
    var capture = opts.capture ? '' : '?:';
    var win32 = utils.isWindows(options);
    // create constants based on platform, for windows or posix
    var PLATFORM_CHARS = constants.globChars(win32);
    var EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    var DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL, PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL, SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL, ONE_CHAR = PLATFORM_CHARS.ONE_CHAR, DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH, NO_DOT = PLATFORM_CHARS.NO_DOT, NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH, NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH, QMARK = PLATFORM_CHARS.QMARK, QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT, STAR = PLATFORM_CHARS.STAR, START_ANCHOR = PLATFORM_CHARS.START_ANCHOR;
    var globstar = function (opts) {
        return "(" + capture + "(?:(?!" + START_ANCHOR + (opts.dot ? DOTS_SLASH : DOT_LITERAL) + ").)*?)";
    };
    var nodot = opts.dot ? '' : NO_DOT;
    var qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    var star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
        star = "(" + star + ")";
    }
    // minimatch options support
    if (typeof opts.noext === 'boolean') {
        opts.noextglob = opts.noext;
    }
    var state = {
        input: input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: '',
        output: '',
        prefix: '',
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        tokens: tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    var extglobs = [];
    var stack = [];
    var prev = bos;
    var value;
    /**
     * Tokenizing helpers
     */
    var eos = function () { return state.index === len - 1; };
    var peek = state.peek = function (n) {
        if (n === void 0) { n = 1; }
        return input[state.index + n];
    };
    var advance = state.advance = function () { return input[++state.index]; };
    var remaining = function () { return input.slice(state.index + 1); };
    var consume = function (value, num) {
        if (value === void 0) { value = ''; }
        if (num === void 0) { num = 0; }
        state.consumed += value;
        state.index += num;
    };
    var append = function (token) {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
    };
    var negate = function () {
        var count = 1;
        while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
            advance();
            state.start++;
            count++;
        }
        if (count % 2 === 0) {
            return false;
        }
        state.negated = true;
        state.start++;
        return true;
    };
    var increment = function (type) {
        state[type]++;
        stack.push(type);
    };
    var decrement = function (type) {
        state[type]--;
        stack.pop();
    };
    /**
     * Push tokens onto the tokens array. This helper speeds up
     * tokenizing by 1) helping us avoid backtracking as much as possible,
     * and 2) helping us avoid creating extra tokens when consecutive
     * characters are plain text. This improves performance and simplifies
     * lookbehinds.
     */
    var push = function (tok) {
        if (prev.type === 'globstar') {
            var isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
            var isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));
            if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
                state.output = state.output.slice(0, -prev.output.length);
                prev.type = 'star';
                prev.value = '*';
                prev.output = star;
                state.output += prev.output;
            }
        }
        if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
            extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
            append(tok);
        if (prev && prev.type === 'text' && tok.type === 'text') {
            prev.value += tok.value;
            return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
    };
    var extglobOpen = function (type, value) {
        var token = __assign(__assign({}, EXTGLOB_CHARS[value]), { conditions: 1, inner: '' });
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        var output = (opts.capture ? '(' : '') + token.open;
        increment('parens');
        push({ type: type, value: value, output: state.output ? '' : ONE_CHAR });
        push({ type: 'paren', extglob: true, value: advance(), output: output });
        extglobs.push(token);
    };
    var extglobClose = function (token) {
        var output = token.close + (opts.capture ? ')' : '');
        if (token.type === 'negate') {
            var extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
                extglobStar = globstar(opts);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
                output = token.close = ')$))' + extglobStar;
            }
            if (token.prev.type === 'bos' && eos()) {
                state.negatedExtglob = true;
            }
        }
        push({ type: 'paren', extglob: true, value: value, output: output });
        decrement('parens');
    };
    /**
     * Fast paths
     */
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        var backslashes_1 = false;
        var output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function (m, esc, chars, first, rest, index) {
            if (first === '\\') {
                backslashes_1 = true;
                return m;
            }
            if (first === '?') {
                if (esc) {
                    return esc + first + (rest ? QMARK.repeat(rest.length) : '');
                }
                if (index === 0) {
                    return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
                }
                return QMARK.repeat(chars.length);
            }
            if (first === '.') {
                return DOT_LITERAL.repeat(chars.length);
            }
            if (first === '*') {
                if (esc) {
                    return esc + first + (rest ? star : '');
                }
                return star;
            }
            return esc ? m : '\\' + m;
        });
        if (backslashes_1 === true) {
            if (opts.unescape === true) {
                output = output.replace(/\\/g, '');
            }
            else {
                output = output.replace(/\\+/g, function (m) {
                    return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
                });
            }
        }
        if (output === input && opts.contains === true) {
            state.output = input;
            return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
    }
    /**
     * Tokenize input until we reach end-of-string
     */
    while (!eos()) {
        value = advance();
        if (value === '\u0000') {
            continue;
        }
        /**
         * Escaped characters
         */
        if (value === '\\') {
            var next = peek();
            if (next === '/' && opts.bash !== true) {
                continue;
            }
            if (next === '.' || next === ';') {
                continue;
            }
            if (!next) {
                value += '\\';
                push({ type: 'text', value: value });
                continue;
            }
            // collapse slashes to reduce potential for exploits
            var match = /^\\+/.exec(remaining());
            var slashes = 0;
            if (match && match[0].length > 2) {
                slashes = match[0].length;
                state.index += slashes;
                if (slashes % 2 !== 0) {
                    value += '\\';
                }
            }
            if (opts.unescape === true) {
                value = advance() || '';
            }
            else {
                value += advance() || '';
            }
            if (state.brackets === 0) {
                push({ type: 'text', value: value });
                continue;
            }
        }
        /**
         * If we're inside a regex character class, continue
         * until we reach the closing bracket.
         */
        if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
            if (opts.posix !== false && value === ':') {
                var inner = prev.value.slice(1);
                if (inner.includes('[')) {
                    prev.posix = true;
                    if (inner.includes(':')) {
                        var idx = prev.value.lastIndexOf('[');
                        var pre = prev.value.slice(0, idx);
                        var rest_1 = prev.value.slice(idx + 2);
                        var posix = POSIX_REGEX_SOURCE[rest_1];
                        if (posix) {
                            prev.value = pre + posix;
                            state.backtrack = true;
                            advance();
                            if (!bos.output && tokens.indexOf(prev) === 1) {
                                bos.output = ONE_CHAR;
                            }
                            continue;
                        }
                    }
                }
            }
            if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
                value = '\\' + value;
            }
            if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
                value = '\\' + value;
            }
            if (opts.posix === true && value === '!' && prev.value === '[') {
                value = '^';
            }
            prev.value += value;
            append({ value: value });
            continue;
        }
        /**
         * If we're inside a quoted string, continue
         * until we reach the closing double quote.
         */
        if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value: value });
            continue;
        }
        /**
         * Double quotes
         */
        if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
                push({ type: 'text', value: value });
            }
            continue;
        }
        /**
         * Parentheses
         */
        if (value === '(') {
            increment('parens');
            push({ type: 'paren', value: value });
            continue;
        }
        if (value === ')') {
            if (state.parens === 0 && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError('opening', '('));
            }
            var extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop());
                continue;
            }
            push({ type: 'paren', value: value, output: state.parens ? ')' : '\\)' });
            decrement('parens');
            continue;
        }
        /**
         * Square brackets
         */
        if (value === '[') {
            if (opts.nobracket === true || !remaining().includes(']')) {
                if (opts.nobracket !== true && opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError('closing', ']'));
                }
                value = '\\' + value;
            }
            else {
                increment('brackets');
            }
            push({ type: 'bracket', value: value });
            continue;
        }
        if (value === ']') {
            if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
                push({ type: 'text', value: value, output: '\\' + value });
                continue;
            }
            if (state.brackets === 0) {
                if (opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError('opening', '['));
                }
                push({ type: 'text', value: value, output: '\\' + value });
                continue;
            }
            decrement('brackets');
            var prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
                value = '/' + value;
            }
            prev.value += value;
            append({ value: value });
            // when literal brackets are explicitly disabled
            // assume we should match with a regex character class
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
                continue;
            }
            var escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            // when literal brackets are explicitly enabled
            // assume we should escape the brackets to match literal characters
            if (opts.literalBrackets === true) {
                state.output += escaped;
                prev.value = escaped;
                continue;
            }
            // when the user specifies nothing, try to match both
            prev.value = "(" + capture + escaped + "|" + prev.value + ")";
            state.output += prev.value;
            continue;
        }
        /**
         * Braces
         */
        if (value === '{' && opts.nobrace !== true) {
            increment('braces');
            push({ type: 'brace', value: value, output: '(' });
            continue;
        }
        if (value === '}') {
            if (opts.nobrace === true || state.braces === 0) {
                push({ type: 'text', value: value, output: value });
                continue;
            }
            var output = ')';
            if (state.dots === true) {
                var arr = tokens.slice();
                var range = [];
                for (var i = arr.length - 1; i >= 0; i--) {
                    tokens.pop();
                    if (arr[i].type === 'brace') {
                        break;
                    }
                    if (arr[i].type !== 'dots') {
                        range.unshift(arr[i].value);
                    }
                }
                output = expandRange(range, opts);
                state.backtrack = true;
            }
            push({ type: 'brace', value: value, output: output });
            decrement('braces');
            continue;
        }
        /**
         * Pipes
         */
        if (value === '|') {
            if (extglobs.length > 0) {
                extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: 'text', value: value });
            continue;
        }
        /**
         * Commas
         */
        if (value === ',') {
            var output = value;
            if (state.braces > 0 && stack[stack.length - 1] === 'braces') {
                output = '|';
            }
            push({ type: 'comma', value: value, output: output });
            continue;
        }
        /**
         * Slashes
         */
        if (value === '/') {
            // if the beginning of the glob is "./", advance the start
            // to the current index, and don't add the "./" characters
            // to the state. This greatly simplifies lookbehinds when
            // checking for BOS characters like "!" and "." (not "./")
            if (prev.type === 'dot' && state.index === state.start + 1) {
                state.start = state.index + 1;
                state.consumed = '';
                state.output = '';
                tokens.pop();
                prev = bos; // reset "prev" to the first token
                continue;
            }
            push({ type: 'slash', value: value, output: SLASH_LITERAL });
            continue;
        }
        /**
         * Dots
         */
        if (value === '.') {
            if (state.braces > 0 && prev.type === 'dot') {
                if (prev.value === '.')
                    prev.output = DOT_LITERAL;
                prev.type = 'dots';
                prev.output += value;
                prev.value += value;
                state.dots = true;
                continue;
            }
            if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
                push({ type: 'text', value: value, output: DOT_LITERAL });
                continue;
            }
            push({ type: 'dot', value: value, output: DOT_LITERAL });
            continue;
        }
        /**
         * Question marks
         */
        if (value === '?') {
            var isGroup = prev && prev.value === '(';
            if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                extglobOpen('qmark', value);
                continue;
            }
            if (prev && prev.type === 'paren') {
                var next = peek();
                var output = value;
                if (next === '<' && !utils.supportsLookbehinds()) {
                    throw new Error('Node.js v10 or higher is required for regex lookbehinds');
                }
                if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
                    output = '\\' + value;
                }
                push({ type: 'text', value: value, output: output });
                continue;
            }
            if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
                push({ type: 'qmark', value: value, output: QMARK_NO_DOT });
                continue;
            }
            push({ type: 'qmark', value: value, output: QMARK });
            continue;
        }
        /**
         * Exclamation
         */
        if (value === '!') {
            if (opts.noextglob !== true && peek() === '(') {
                if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
                    extglobOpen('negate', value);
                    continue;
                }
            }
            if (opts.nonegate !== true && state.index === 0) {
                negate(state);
                continue;
            }
        }
        /**
         * Plus
         */
        if (value === '+') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                extglobOpen('plus', value);
                continue;
            }
            if ((prev && prev.value === '(') || opts.regex === false) {
                push({ type: 'plus', value: value, output: PLUS_LITERAL });
                continue;
            }
            if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
                push({ type: 'plus', value: value });
                continue;
            }
            push({ type: 'plus', value: PLUS_LITERAL });
            continue;
        }
        /**
         * Plain text
         */
        if (value === '@') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                push({ type: 'at', extglob: true, value: value, output: '' });
                continue;
            }
            push({ type: 'text', value: value });
            continue;
        }
        /**
         * Plain text
         */
        if (value !== '*') {
            if (value === '$' || value === '^') {
                value = '\\' + value;
            }
            var match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
                value += match[0];
                state.index += match[0].length;
            }
            push({ type: 'text', value: value });
            continue;
        }
        /**
         * Stars
         */
        if (prev && (prev.type === 'globstar' || prev.star === true)) {
            prev.type = 'star';
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            consume(value);
            continue;
        }
        var rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen('star', value);
            continue;
        }
        if (prev.type === 'star') {
            if (opts.noglobstar === true) {
                consume(value);
                continue;
            }
            var prior = prev.prev;
            var before = prior.prev;
            var isStart = prior.type === 'slash' || prior.type === 'bos';
            var afterStar = before && (before.type === 'star' || before.type === 'globstar');
            if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
                push({ type: 'star', value: value, output: '' });
                continue;
            }
            var isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
            var isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
            if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
                push({ type: 'star', value: value, output: '' });
                continue;
            }
            // strip consecutive `/**/`
            while (rest.slice(0, 3) === '/**') {
                var after = input[state.index + 4];
                if (after && after !== '/') {
                    break;
                }
                rest = rest.slice(3);
                consume('/**', 3);
            }
            if (prior.type === 'bos' && eos()) {
                prev.type = 'globstar';
                prev.value += value;
                prev.output = globstar(opts);
                state.output = prev.output;
                consume(value);
                continue;
            }
            if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = '(?:' + prior.output;
                prev.type = 'globstar';
                prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
                prev.value += value;
                state.output += prior.output + prev.output;
                consume(value);
                continue;
            }
            if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
                var end = rest[1] !== void 0 ? '|$' : '';
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = '(?:' + prior.output;
                prev.type = 'globstar';
                prev.output = "" + globstar(opts) + SLASH_LITERAL + "|" + SLASH_LITERAL + end + ")";
                prev.value += value;
                state.output += prior.output + prev.output;
                consume(value + advance());
                push({ type: 'slash', value: value, output: '' });
                continue;
            }
            if (prior.type === 'bos' && rest[0] === '/') {
                prev.type = 'globstar';
                prev.value += value;
                prev.output = "(?:^|" + SLASH_LITERAL + "|" + globstar(opts) + SLASH_LITERAL + ")";
                state.output = prev.output;
                consume(value + advance());
                push({ type: 'slash', value: value, output: '' });
                continue;
            }
            // remove single star from output
            state.output = state.output.slice(0, -prev.output.length);
            // reset previous token to globstar
            prev.type = 'globstar';
            prev.output = globstar(opts);
            prev.value += value;
            // reset output with globstar
            state.output += prev.output;
            consume(value);
            continue;
        }
        var token = { type: 'star', value: value, output: star };
        if (opts.bash === true) {
            token.output = '.*?';
            if (prev.type === 'bos' || prev.type === 'slash') {
                token.output = nodot + token.output;
            }
            push(token);
            continue;
        }
        if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
        }
        if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
            if (prev.type === 'dot') {
                state.output += NO_DOT_SLASH;
                prev.output += NO_DOT_SLASH;
            }
            else if (opts.dot === true) {
                state.output += NO_DOTS_SLASH;
                prev.output += NO_DOTS_SLASH;
            }
            else {
                state.output += nodot;
                prev.output += nodot;
            }
            if (peek() !== '*') {
                state.output += ONE_CHAR;
                prev.output += ONE_CHAR;
            }
        }
        push(token);
    }
    while (state.brackets > 0) {
        if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError('closing', ']'));
        state.output = utils.escapeLast(state.output, '[');
        decrement('brackets');
    }
    while (state.parens > 0) {
        if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError('closing', ')'));
        state.output = utils.escapeLast(state.output, '(');
        decrement('parens');
    }
    while (state.braces > 0) {
        if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError('closing', '}'));
        state.output = utils.escapeLast(state.output, '{');
        decrement('braces');
    }
    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
        push({ type: 'maybe_slash', value: '', output: SLASH_LITERAL + "?" });
    }
    // rebuild the output if we had to backtrack at any point
    if (state.backtrack === true) {
        state.output = '';
        for (var _i = 0, _a = state.tokens; _i < _a.length; _i++) {
            var token = _a[_i];
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
                state.output += token.suffix;
            }
        }
    }
    return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */
parse.fastpaths = function (input, options) {
    var opts = __assign({}, options);
    var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    var len = input.length;
    if (len > max) {
        throw new SyntaxError("Input length: " + len + ", exceeds maximum allowed length: " + max);
    }
    input = REPLACEMENTS[input] || input;
    var win32 = utils.isWindows(options);
    // create constants based on platform, for windows or posix
    var _a = constants.globChars(win32), DOT_LITERAL = _a.DOT_LITERAL, SLASH_LITERAL = _a.SLASH_LITERAL, ONE_CHAR = _a.ONE_CHAR, DOTS_SLASH = _a.DOTS_SLASH, NO_DOT = _a.NO_DOT, NO_DOTS = _a.NO_DOTS, NO_DOTS_SLASH = _a.NO_DOTS_SLASH, STAR = _a.STAR, START_ANCHOR = _a.START_ANCHOR;
    var nodot = opts.dot ? NO_DOTS : NO_DOT;
    var slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    var capture = opts.capture ? '' : '?:';
    var state = { negated: false, prefix: '' };
    var star = opts.bash === true ? '.*?' : STAR;
    if (opts.capture) {
        star = "(" + star + ")";
    }
    var globstar = function (opts) {
        if (opts.noglobstar === true)
            return star;
        return "(" + capture + "(?:(?!" + START_ANCHOR + (opts.dot ? DOTS_SLASH : DOT_LITERAL) + ").)*?)";
    };
    var create = function (str) {
        switch (str) {
            case '*':
                return "" + nodot + ONE_CHAR + star;
            case '.*':
                return "" + DOT_LITERAL + ONE_CHAR + star;
            case '*.*':
                return "" + nodot + star + DOT_LITERAL + ONE_CHAR + star;
            case '*/*':
                return "" + nodot + star + SLASH_LITERAL + ONE_CHAR + slashDot + star;
            case '**':
                return nodot + globstar(opts);
            case '**/*':
                return "(?:" + nodot + globstar(opts) + SLASH_LITERAL + ")?" + slashDot + ONE_CHAR + star;
            case '**/*.*':
                return "(?:" + nodot + globstar(opts) + SLASH_LITERAL + ")?" + slashDot + star + DOT_LITERAL + ONE_CHAR + star;
            case '**/.*':
                return "(?:" + nodot + globstar(opts) + SLASH_LITERAL + ")?" + DOT_LITERAL + ONE_CHAR + star;
            default: {
                var match = /^(.*?)\.(\w+)$/.exec(str);
                if (!match)
                    return;
                var source_1 = create(match[1], options);
                if (!source_1)
                    return;
                return source_1 + DOT_LITERAL + match[2];
            }
        }
    };
    var output = utils.removePrefix(input, state);
    var source = create(output);
    if (source && opts.strictSlashes !== true) {
        source += SLASH_LITERAL + "?";
    }
    return source;
};
module.exports = parse;
