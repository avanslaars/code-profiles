/// <reference types="node" />
import { ChannelOptions } from "./ChannelOptions";
import { IDisposableObservable } from "./IDisposableObservable";
import { MultiplexingStreamClass } from "./MultiplexingStream";
import { OfferParameters } from "./OfferParameters";
import { AcceptanceParameters } from "./AcceptanceParameters";
export declare abstract class Channel implements IDisposableObservable {
    /**
     * The id of the channel.
     */
    readonly id: number;
    /**
     * A read/write stream used to communicate over this channel.
     */
    abstract stream: NodeJS.ReadWriteStream;
    /**
     * A promise that completes when this channel has been accepted/rejected by the remote party.
     */
    abstract acceptance: Promise<void>;
    /**
     * A promise that completes when this channel is closed.
     */
    abstract completion: Promise<void>;
    private _isDisposed;
    constructor(id: number);
    /**
     * Gets a value indicating whether this channel has been disposed.
     */
    get isDisposed(): boolean;
    /**
     * Closes this channel.
     */
    dispose(): void;
}
export declare class ChannelClass extends Channel {
    readonly name: string;
    private _duplex;
    private readonly _multiplexingStream;
    private readonly _acceptance;
    private readonly _completion;
    localWindowSize?: number;
    private remoteWindowSize?;
    /**
     * The number of bytes transmitted from here but not yet acknowledged as processed from there,
     * and thus occupying some portion of the full AcceptanceParameters.RemoteWindowSize.
     */
    private remoteWindowFilled;
    /** A signal which indicates when the <see cref="RemoteWindowRemaining"/> is non-zero. */
    private remoteWindowHasCapacity;
    constructor(multiplexingStream: MultiplexingStreamClass, offeredLocally: boolean, id: number, offerParameters: OfferParameters);
    get stream(): NodeJS.ReadWriteStream;
    get acceptance(): Promise<void>;
    get isAccepted(): boolean;
    get isRejectedOrCanceled(): boolean;
    get completion(): Promise<void>;
    tryAcceptOffer(options?: ChannelOptions): boolean;
    tryCancelOffer(reason: any): void;
    onAccepted(acceptanceParameter: AcceptanceParameters): boolean;
    onContent(buffer: Buffer | null): void;
    onContentProcessed(bytesProcessed: number): void;
    dispose(): void;
    private onTransmittingBytes;
}
